#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import os
import sys
import six
import yaml
from pprint import pformat
from time import sleep
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter, FileType
from subprocess import call

get_input = raw_input if six.PY2 else input

import DiscID, CDDB
try:
    import discogs_client
    HAS_DISCOGS=True
except ImportError:
    HAS_DISCOGS=False


exit_codes = {'disc_drive': 11,
              'freedb_query': 21,
              'disc_dir': 31,
              'rip_disc': 41}


def encode_dict(d, coding):
    '''
    encode top level key and value strings in `d` in `encoding`
    '''
    transcoded_d = {}
    for k,v in d.items():
        try:
            if isinstance(k, six.string_types):
                k = k.decode(coding, 'ignore').encode('UTF-8')
            if isinstance(v, six.string_types):
                v = v.decode(coding, 'ignore').encode('UTF-8')
        except UnicodeDecodeError:
            pass
        transcoded_d[k] = v
    return transcoded_d


class TextFormat(object):
    '''
    ANSI Select Graphic Rendition (SGR) code escape sequence.
    '''
    prefix = '\x1b['
    suffix = 'm'
    all_codes = {
        'reset': '0',

        'bold': '1',
        'faint': '2',
        'italic': '3',
        'underline': '4',

        'black': '30',
        'red': '31',
        'green': '32',
        'yellow': '33',
        'blue': '34',
        'magenta': '35',
        'cyan': '36',
        'white': '37',
        'extended': '38',
        'default': '39',
    }

    def __init__(self, *attrs, **kwargs):
        '''
        :param attrs: are the attribute names of any format codes in `codes`

        :param kwargs: may contain

        `reset`, prepend reset SGR code to sequence (default `True`)

        Example:

        .. code-block:: python

            red_underlined = TextFormat('red', 'underline')
            print(
                '{0}Can you read this?{1}'
                ).format(red_underlined, TextFormat('reset'))
        '''
        self.codes = [self.all_codes[attr.lower()] for attr in attrs if isinstance(attr, six.string_types)]

        if kwargs.get('reset', True):
            self.codes[:0] = [self.all_codes['reset']]

        self.opts = kwargs.get('opts', {})

        if self.opts.get('no_color', False):
            self.sequence = ''
        else:
            self.sequence = '%s%s%s' % (self.prefix, ';'.join(self.codes), self.suffix)

    def __call__(self, text, reset=True):
        '''
        Format :param text: by prefixing `self.sequence` and suffixing the
        reset sequence if :param reset: is `True`.

        Examples:

        .. code-block:: python

            green_text = TextFormat('blink', 'green')
            'The answer is: {0}'.format(green_text(42))
        '''
        end = TextFormat('reset') if reset else ''
        return '%s%s%s' % (self.sequence, text, end)

    def __str__(self):
        return self.sequence

    def __repr__(self):
        return self.sequence


class Input(object):
    '''
    prompt for and collect user input
    '''
    def __init__(self, opts):
        '''
        setup opts
        '''
        self.opts = opts
        self.prompt_text = TextFormat('bold', 'green')
        self.invalid_text = TextFormat('bold', 'red')

    def __call__(self, prompt, input_type, valid=None, action=None):
        '''
        prompt the user until valid input is received

        `prompt`: the text presented to the user

        `input_type`: a description of the kind of input expected

        `valid`: an iterable of valid responses which are expected to be of
        type `str` or a single string, both in all lowercase

        `action`: a function that is run with the collected input as an
        argument

        if `action` is given, the input and the results of `action` on the
        input are returned, otherwise only the input is returned
        '''
        while True:
            try:
                value = get_input(self.prompt_text(prompt))
                if action:
                    return value, action(value)
            except Exception:
                value = None
            if valid:
                if value.lower() in [v.lower() for v in valid]:
                    return value.lower()
            print(self.invalid_text('Invalid {0}'.format(input_type)))


class DiscDrive(object):
    '''
    interaction with disc drive
    '''
    def __init__(self, opts):
        '''
        setup options
        '''
        self.opts = opts

    def close(self):
        '''
        close disc drive drawer
        '''
        if call(['eject', '-t']) != 0:
            print('\nFailed to close disc drive drawer')
            sys.exit(exit_codes['disc_drive'])

    def open(self):
        '''
        open disc drive drawer
        '''
        if call(['eject']) != 0:
            print('\nFailed to open disc drive')
            sys.exit(exit_codes['disc_drive'])


class FreeDB(object):
    '''
    interaction with freedb
    '''
    def __init__(self, opts):
        '''
        setup parameters, options
        '''
        self.opts = opts
        self.client_name, self.client_version = opts['agent'].split('/')
        disc_id = DiscID.disc_id(DiscID.open(opts['device']))
        self.info = {'disc_id': disc_id, 'record': []}

        self.input = Input(opts)
        self.header_text = TextFormat('bold', 'blue')
        self.disc_text = TextFormat('magenta')
        self.track_text = TextFormat('yellow')

        self.get_disc_info()
        self.get_track_info()
        self.set_encodings()
        self.get_preferred()

    def _present_results(self, number=None, entry=None):
        '''
        present retrieved disc info to the user
        '''
        def present_result(number, entry):
            '''
            print info from a single entry
            '''
            print(self.header_text('\n===== Result {0:>02} =====\n'.format(number + 1)))
            print(self.disc_text(pformat(entry['disc_info']))) ; print('')
            for track in range(self.info['disc_id'][1]):
                track_title = entry['track_info']['TTITLE{0}'.format(track)]
                print(self.track_text('{0:>02d} - {1}'.format(track + 1, track_title)))
            print(self.header_text('\n=====================\n'))

        if number is not None and entry is not None:
            present_result(number, entry)
        else:
            for num, ent in enumerate(self.info['record']):
                present_result(num, ent)

    def get_disc_info(self):
        '''
        retrieve disc info
        '''
        status, results = CDDB.query(self.info['disc_id'],
                                     server_url=self.opts['freedb_mirror'],
                                     client_name=self.client_name,
                                     client_version=self.client_version)

        if not str(status).startswith('2'):
            print('Failed to query freedb mirror "{0}" for disc info on disc_id "{1}": '
                  'HTTP code {2}'.format(self.opts['freedb_mirror'], self.info['disc_id'][0], status))
            sys.exit(exit_codes['freedb_query'])

        # a single result will not be enclosed in a list by the CDDB lib
        self.results = [results] if isinstance(results, dict) else results

    def get_track_info(self):
        '''
        retrieve track info for each disc info result
        '''
        for result in self.results:
            sleep(1)  # throttle query rate
            status, track_info = CDDB.read(result['category'],
                                           result['disc_id'],
                                           server_url=self.opts['freedb_mirror'],
                                           client_name=self.client_name,
                                           client_version=self.client_version)

            if not str(status).startswith('2'):
                print('Failed to query freedb mirror {0} for track info: '
                      'HTTP code {1}'.format(self.opts['freedb_mirror'], status))
                sys.exit(exit_codes['freedb_query'])

            self.info['record'].append({'disc_info': result, 'track_info': track_info})

    def set_encodings(self):
        '''
        set input character encoding for each info set
        '''
        def decode_info(coding):
            '''
            decode disc and track info with `coding`
            '''
            disc_info = encode_dict(entry['disc_info'], coding)
            track_info = encode_dict(entry['track_info'], coding)
            return {'disc_info': disc_info, 'track_info': track_info}

        if not len(self.info['record']):
            return  # only the TOC is known; no disc and track titles available

        suggested_encodings = ['iso-8859-1', 'iso-8859-2', 'UTF-8']
        coding_prompt = 'Try an encoding (suggested: {0}): '.format(suggested_encodings)
        yes = ['', 'y', 'yes'] ; no = ['n', 'no']

        # this is a second order prompt loop
        for number, entry in enumerate(self.info['record']):
            accepted = False
            while not accepted:
                self._present_results(number, entry)
                coding, decoded_entry = self.input(coding_prompt, 'encoding', action=decode_info)

                self._present_results(number, decoded_entry)
                accept_prompt = 'Accept source encoding ({0})? [Y/n] '.format(coding)
                accept = self.input(accept_prompt, 'answer', valid=yes + no)
                if accept in yes:
                    accepted = True
                    self.info['record'][number] = decoded_entry

    def get_preferred(self):
        '''
        get preferred info set
        '''
        self._present_results()

        if len(self.info['record']) == 0:
            print('\nNo freedb results found for disc')
            return
        elif len(self.info['record']) == 1:
            selected_entry = self.info['record'][0]
            self.info['record'][0]['preferred'] = True
        else:
            select_range = '[1-{0}]'.format(len(self.info['record']))
            prompt = 'Select a preferred result {0}: '.format(select_range)
            valid = [i for i in range(1, len(self.info['record']) + 1)]
            selected_number = self.input(prompt, 'result', valid=valid)
            selected_entry = self.info['record'][selected_number - 1]
            selected_entry['preferred'] = True

        print('\nSelected result: {0}\n'.format(selected_entry['disc_info']['title']))


class Discogs(object):
    '''
    interaction with discogs
    '''
    def __init__(self, opts):
        '''
        setup options
        '''
        if not HAS_DISCOGS:
            print('discogs client library is unavailable')
        else:
            self.opts = opts
            self.d = discogs_client.Client(self.opts['agent'],
                                           user_token=self.opts['token'])

    def query(self, search):
        '''
        query discogs database
        '''
        if not HAS_DISCOGS:
            print('discogs client library is unavailable')
        else:
            results = self.d.search('Stockholm By Night', type='release')
            artist = results[0].artists[0]
            releases = d.search('Bit Shifter', type='artist')[0].releases[1].versions[0].labels[0].releases
            for release in releases:
                print(release)


class CDParanoia(object):
    '''
    interaction with cdparanoia
    '''
    def __init__(self, opts, disc_info):
        '''
        setup options and disc information
        '''
        self.opts = opts
        self.disc_info = disc_info

        self.setup_dir()
        self.rip_tracks()
        self.rename_tracks()
        self.save_disc_info()

    def setup_dir(self):
        '''
        setup disc directory
        '''
        disc_dir = ''
        self.preferred = None
        for number, entry in enumerate(self.disc_info['record']):
            if 'preferred' in entry:
                self.preferred = number
                disc_dir = entry['disc_info']['title'].replace('/', '::')
        if not disc_dir:
            disc_dir = self.disc_info['disc_id'][0]

        self.dest_dir = os.path.join(self.opts['library_dir'], disc_dir)
        if os.path.exists(self.dest_dir):
            if self.opts['force']:
                for track in os.listdir(self.dest_dir):
                    os.remove(track)
                os.rmdir(self.dest_dir)
            else:
                print('Destination directory, "{0}", exists'.format(self.dest_dir))
                sys.exit(exit_codes['disc_dir'])

        if not os.path.exists(self.dest_dir):
            os.makedirs(self.dest_dir)

    def rip_tracks(self):
        '''
        rip all tracks from the disc
        '''
        cmd = ['cdparanoia', '--log-debug=/dev/null',
                             '--log-summary=/dev/null',
                             '--output-wav',
                             '--batch',
                             '--force-read-speed={0}'.format(self.opts['read_speed']),
                             '--never-skip']
        if call(cmd, cwd=self.dest_dir) != 0:
            print('\nFailed to rip disc')
            sys.exit(exit_codes['rip_disc'])

    def rename_tracks(self):
        '''
        rename ripped tracks
        '''
        # not all discs have a TOC track
        TOC_source = os.path.join(self.dest_dir, 'track00.cdda.wav')
        if os.path.exists(TOC_source):
            TOC_dest = os.path.join(self.dest_dir, '00 - disc TOC.wav')
            os.rename(TOC_source, TOC_dest)

        if self.preferred is not None:
            for track_number in range(self.disc_info['disc_id'][1]):
                old_name = 'track{0:02}.cdda.wav'.format(track_number + 1)
                track_name = self.disc_info['record'][self.preferred]['track_info']['TTITLE{0}'.format(track_number)]
                new_name = '{0:02} - {1}.wav'.format(track_number + 1, track_name)
                os.rename(os.path.join(self.dest_dir, old_name), os.path.join(self.dest_dir, new_name))

    def save_disc_info(self):
        '''
        save disc TOC and database record in disc directory
        '''
        if not len(self.disc_info['record']):
            print('\nNo CDDA database records were found for {0}; '
                  'you will need to name the disc directory, {1}, and tracks manually'
                  ''.format(self.disc_info['disc_id'][0], self.dest_dir))

        with open(os.path.join(self.dest_dir, '00 - disc info.yaml'), 'wb') as disc_record:
            disc_record.write(yaml.dump(self.disc_info))


class FLAC(object):
    '''
    flac interaction
    '''
    def __init__(self, opts, disc_dir=None):
        '''
        setup opts
        '''
        self.opts = opts
        if disc_dir:
            self.rip_dir = disc_dir

        self.encode()

    def encode(self):
        '''
        encode all `*.wav` files in the disc directory
        '''
        def encode_disc(cmd, disc_dir):
            '''
            encode all the tracks from a disc
            '''
            for track_name in os.listdir(disc_dir):
                if track_name.endswith('.wav'):
                    call(cmd + [track_name], cwd=disc_dir)

        cmd = ['flac', '--keep-foreign-metadata']
        if not self.opts['no_verify_encoding']:
            cmd.append('--verify')
        if not self.opts['keep_wav']:
            cmd.append('--delete-input-file')

        if hasattr(self, 'rip_dir'):
            encode_disc(cmd, self.rip_dir)
        elif self.opts['encode_dir']:
            encode_disc(cmd, os.path.join(self.opts['library_dir'], self.opts['encode_dir']))
        else:
            for disc_dir in os.listdir(self.opts['library_dir']):
                encode_disc(cmd, os.path.join(self.opts['library_dir'], disc_dir))


def get_opts():
    '''
    setup program options
    '''
    script_dir = os.path.split(__file__)[0]
    agent_file = os.path.join(script_dir, 'agent')
    token_file = os.path.join(script_dir, 'token')

    library_dir = os.path.join(os.environ['HOME'], 'Music')

    def parse_args():
        '''
        process invocation arguments
        '''
        desc = 'rip CDDA discs and flac encode and tag the tracks with info from a CDDA database'
        parser = ArgumentParser(description=desc, formatter_class=ArgumentDefaultsHelpFormatter)
        parser.add_argument('action',
                            nargs='*',
                            help='`rip`: rip CDDA tracks, `encode`: encode tracks in flac format; '
                                 'if both arguments are given, the disc is ripped '
                                 'and the tracks are encoded sequentially as a single operation, '
                                 'otherwise if only `rip` is given, only ripping occurs, or '
                                 'if only `encode` is specified, all unencoded tracks in the library dir are encoded')
        parser.add_argument('-d', '--device',
                            type=str,
                            default='/dev/sr0',
                            help='CD drive device name')
        parser.add_argument('-a', '--agent-file',
                            type=FileType('rb'),
                            default=agent_file,
                            help='file containing HTTP client agent name and version conforming to RFC 1945 §3.7')
        parser.add_argument('-t', '--token-file',
                            type=FileType('rb'),
                            default=token_file,
                            help='file containing discogs API token')
        parser.add_argument('-m', '--freedb-mirror',
                            type=str,
                            default='http://freedb.freedb.org/~cddb/cddb.cgi',
                            help='freedb mirror URL')
        parser.add_argument('-l', '--library-dir',
                            type=str,
                            default=library_dir,
                            help='base directory of music library')
        parser.add_argument('-s', '--read-speed',
                            type=int,
                            default=8,
                            help='disc drive read speed')
        parser.add_argument('-f', '--force',
                            action='store_true',
                            help='overwrite existing disc directory if it exists')
        parser.add_argument('-n', '--no-verify-encoding',
                            action='store_true',
                            help='do not verify that flac encoded files match their source wav files')
        parser.add_argument('-k', '--keep-wav',
                            action='store_true',
                            help='do not delete wave files after successful flac encoding')
        parser.add_argument('-e', '--encode-dir',
                            type=str,
                            help='encode the tracks in a specific disc dir')
        parser.add_argument('-C', '--no-color',
                            action='store_true',
                            help='disable colorized output')

        return vars(parser.parse_args())

    opts = parse_args()

    opts['agent'] = opts['agent_file'].read().strip() ; del opts['agent_file']
    opts['token'] = opts['token_file'].read().strip() ; del opts['token_file']
    opts['action'] = set(opts['action'])

    return opts


def main():
    '''
    rip CDDA discs and flac encode and tag the tracks with info from a CDDA
    database
    '''
    opts = get_opts()

    if 'rip' in opts['action']:
        disc_drive = DiscDrive(opts)
        disc_drive.close()

        freedb = FreeDB(opts)
        cdparanoia = CDParanoia(opts, freedb.info)

    if {'rip', 'encode'} == opts['action']:
        flac = FLAC(opts, cdparanoia.dest_dir)
    elif 'encode' in opts['action']:
        flac = FLAC(opts)

    if 'rip' in opts['action']:
        disc_drive.open()


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
